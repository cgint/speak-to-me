import os
import traceback
from google.cloud import speech_v2
from google.api_core.client_options import ClientOptions
from dotenv import load_dotenv

load_dotenv()

def transcribe_audio_chirp(audio_file_path: str, project_id: str, location: str = "europe-west1") -> None:
    """
    Transcribes audio using the Google Cloud Speech-to-Text V2 'Chirp' model.
    """
    # Initialize the client with the specific regional endpoint if necessary
    # For V2, utilizing the regional endpoint is often required.
    client_options = ClientOptions(api_endpoint=f"{location}-speech.googleapis.com")
    client = speech_v2.SpeechClient(client_options=client_options)

    # The content of the audio file to transcribe
    try:
        with open(audio_file_path, "rb") as f:
            audio_content = f.read()
    except FileNotFoundError:
        print(f"Error: Audio file not found at {audio_file_path}")
        return

    # Build the recognition config for Chirp
    config = speech_v2.RecognitionConfig(
        auto_decoding_config=speech_v2.AutoDetectDecodingConfig(),
        language_codes=["en-US"],
        model="chirp_3", # Or "chirp_2"
        features=speech_v2.RecognitionFeatures(
            enable_word_time_offsets=True,
        ),
    )

    parent = f"projects/{project_id}/locations/{location}"
    recognizer_id = "chirp-recognizer-test"
    recognizer_name = f"{parent}/recognizers/{recognizer_id}"
    
    print(f"Using parent: {parent}")
    
    # List recognizers to verify existence/path
    try:
        print("Listing recognizers...")
        list_response = client.list_recognizers(parent=parent)
        for r in list_response:
            print(f" - {r.name}")
            if r.name.endswith(f"/recognizers/{recognizer_id}"):
                recognizer_name = r.name # Use the canonical name (with project number)
                print(f"Found existing recognizer: {recognizer_name}")
    except Exception as e:
        print(f"Error listing recognizers: {e}")

    # Create Recognizer request
    # We check if it exists or create it
    try:
        print(f"Ensuring recognizer {recognizer_id} exists...")
        request = speech_v2.CreateRecognizerRequest(
            parent=parent,
            recognizer_id=recognizer_id,
            recognizer=speech_v2.Recognizer(
                default_recognition_config=config,
                model="chirp",
            ),
        )
        # This will fail if it already exists, which is fine
        operation = client.create_recognizer(request=request)
        operation.result() # type: ignore
        print("Recognizer created.")
    except Exception as e:
        if "409" in str(e):
             print("Recognizer already exists.")
        else:
             print(f"Error creating recognizer: {e}")
             # Fallback to wildcard if creation failed (though likely won't work if previous attempt failed)

    request = speech_v2.RecognizeRequest(
        recognizer=recognizer_name, 
        # config=config, # Rely on recognizer defaults to avoid conflicts
        content=audio_content,
    )

    print("Sending request to Speech-to-Text V2 API (Chirp)...")
    response = client.recognize(request=request)
    
    for result in response.results:
        print("-" * 20)
        print(f"Transcript: {result.alternatives[0].transcript}")
        print(f"Confidence: {result.alternatives[0].confidence}")

if __name__ == "__main__":
    try:
        project_id = os.environ.get("GOOGLE_CLOUD_PROJECT") or os.environ.get("VERTEXAI_PROJECT")
        
        if not project_id:
            print("Error: GOOGLE_CLOUD_PROJECT or VERTEXAI_PROJECT not set.")
        else:
            # Use the valid audio file generated by the TTS experiment
            audio_path = "standard_tts_output.wav" 
            # Create a dummy file if it doesn't exist just to test the client init
            if not os.path.exists(audio_path):
                print(f"Warning: {audio_path} not found. Run experiments/standard_tts.py first.")
            else:
                transcribe_audio_chirp(audio_path, project_id)
    except Exception:
        traceback.print_exc()
